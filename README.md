# 前端必备算法
<br>##快速排序 平均时间复杂度：O(nlogn) quickSort.js</br>
===
<br>先从数列中取出一个数作为“基准”；</br>
---
<br>分区过程：将比“基准”大的数全放在“基准”的右边，小于或等于基准的全放到“基准”左边；</br>
---
<br>再对左右区间重复第二步，直到各区间只有一个数；</br>
---
<br>##选择排序 平均时间复杂度：O(n^2)  selectionSort.js </br>
===
<br>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；</br>
---
<br>在剩余未排序序列中继续寻找最小（大）元素，然后放到已排序序列的末尾；</br>
---
<br>重复第二步直到所有元素均排序完毕。</br>
---
<br>##希尔排序</br>
===
<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序</br>
---
1、雪碧图，减少http请求  

2、真实项目中，把css或者js文件合并压缩  
>1)css合并成一个，js最好也合成一个  
>2)webpack 压缩成xxx.min.js  减少文件大小  
>3)服务器开启资源文件的GZIP压缩  
>...  
>自动化构建模式，前端工程化开发  

3、减少对Dom的操作  
>[操作DOM弊端]  
>1)监听机制  
>2)触发回流跟重绘  
>...   

4、图片懒加载技术，在页面开始加载的时候不请求真实的图片地址，用默认图占位，当页面加载完成后，再根据相关的条件依次加载真实图片（减少页面首次加载HTTP请求的次数）  
>第一屏幕中可以看见的图片进行加载，随着页面滚动，再把下面的图片进行加载  
>1)首屏数据或前两屏的数据从服务器端进行请求  
>2)下拉加载，滚动到哪个区域，再请求  
>3)下拉到一定距离后，再请求第二页数据，数据分页技术，懒加载，减少http请求大小和次数  

5、更多使用异步编程  
>1)ajax请求处理异步编程，基于promise设计模式对ajax进行处理（fetch,vue axios)  

6、真实项目中尽可能避免一次性循环过多数据，循环是同步任务，避免while导致的死循环  
7、css选择器优化  
>1)少使用标签选择器  
>2)减少ID选择器，多用样式选择器  
>3)减少选择器前面的前缀，例如：.headerBox .nav .left a{}(选择器是从右向左查找的) 改成.header-nav-left a   

8、避免使用css表达式  
```css
.box{
  background-color:expression((new Date()).getHours()%2?'red':'blue')
}  
```  

15、音视频资源播放的时候再加载，减少页面首次加载http请求的次数  
>preload=auto  
>preload=metadata 只把音视频资源的头部进行加载


